<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Socket IO Test</title>
    <link rel="stylesheet" href="styles.css" />

    <script type="importmap">
      {
        "imports": {
          "socket.io-client": "https://cdn.socket.io/4.7.5/socket.io.esm.min.js"
        }
      }
    </script>
  </head>

  <body>
    <div id="connection-status-box"></div>

    <div>
      <div id="authed-view">
        <p id="auth-status-box"></p>
        <button id="logout-button">Logout</button>
      </div>

      <form id="login-form">
        <p>Login Form</p>
        <div>
          <label for="username">Username</label>
          <input
            type="text"
            placeholder="username"
            name="username"
            id="username"
          />
        </div>
        <div>
          <label for="password">Password</label>
          <input
            type="password"
            name="password"
            id="password"
            placeholder="*****"
          />
        </div>
        <button type="submit">login</button>
      </form>
    </div>

    <div id="chat-room">
      <h3>Chat Room</h3>
      <div style="display: flex">
        <div id="users-space">
          <p>Users</p>
          <div id="users"></div>

          <p>Rooms</p>
          <div id="rooms"></div>
        </div>
        <div id="chat-area"></div>
      </div>

      <form id="chat-form">
        <input
          placeholder="say something!"
          type="text"
          name="new-msg-box"
          id="new-msg-box"
        />
        <button type="submit">send</button>
      </form>
    </div>

    <script type="module">
      import { io } from "socket.io-client";

      const apiBaseURL = "http://localhost:3500";
      const $ = (query) => document.querySelector(query);

      const chatForm = $("#chat-form");
      const loginForm = $("#login-form");
      const statusIndicatorBox = $("#connection-status-box");
      const authStatusBox = $("#auth-status-box");
      const logoutButton = $("#logout-button");
      const chatArea = $("#chat-area");

      let isAuth = false;
      let appReady = false;
      let userDetails = { username: "" };

      const socket = io("http://localhost:3500/", {
        reconnectionDelayMax: 10000,
        withCredentials: true,
      });

      socket.on("connect", () => {
        statusIndicatorBox.innerText + "connected!";
        console.log("connected");
      });

      socket.on("connect_error", (err) => {
        statusIndicatorBox.innerText + "disconnected";
        console.error("Connection failed:", err.message);
      });

      function renderChatBubble(data) {
        const isCurrentUser = data.username === userDetails.username;

        return `
              <div class="chat-bubble ${isCurrentUser ? "current-user" : ""}">
                <p class="chat-bubble-username">~${data.username}</p>
                <div class="chat-bubble-chatdata">
                  <p class="chat-bubble-message">${data.message}</p>
                  <p class="chat-bubble-timestamp">${convertToLocalTime(
                    data.timestamp
                  )}</p>
                </div>
              </div>
            `;
      }

      socket.on("roomPreviousMessages", (messages) => {
        chatArea.innerHTML = "";
        messages.forEach((msg) => {
          chatArea.innerHTML += renderChatBubble(msg);
        });
        scrollToBottom();
      });

      socket.on("roomMessageBroadcast", (msg) => {
        chatArea.innerHTML += renderChatBubble(msg);
        scrollToBottom();
      });

      socket.on("disconnect", () => {
        statusIndicatorBox.innerText + "disconnected";
        console.log("Disconnected from server.");
      });

      /**
       * Fetch wrapper function
       * @param {string} endpoint - The endpoint to fetch data from.
       * @param {"GET" | "POST" | "PUT" | "DELETE"} [method="GET"] - HTTP method.
       * @param {Object} [body=null] - Request body for POST/PUT requests.
       * @param {Object} [headers={}] - Additional headers.
       * @returns {Promise<[any, Error|null]>} - Returns a tuple [data, error].
       */
      const useFetch = async (
        endpoint,
        method = "GET",
        body = null,
        headers = {},
        baseURL = "http://localhost:3500"
      ) => {
        try {
          const options = {
            method,
            headers: { "Content-Type": "application/json", ...headers },
            body: body ? JSON.stringify(body) : null,
            credentials: "include",
          };

          const response = await fetch(`${baseURL}${endpoint}`, options);
          if (!response.ok)
            throw new Error(`${response.status} - ${response.statusText}`);
          return [await response.json(), null];
        } catch (error) {
          return [null, error];
        }
      };

      async function initialDataFetch() {
        const usersFetchReq = useFetch("/users");
        const roomsFetchReq = useFetch("/rooms");

        const [userFetch, roomFetch] = await Promise.all([
          usersFetchReq,
          roomsFetchReq,
        ]);

        const [users, usersError] = userFetch;
        if (usersError) console.error(error);

        users.forEach((user) => {
          $("#users").innerHTML += `
                  <div class="user">
                    <span class="user-status-indicator"></span><p>${user.username}</p>
                  </div>
                  `;
        });

        const [rooms, roomsFetchError] = roomFetch;
        if (roomsFetchError) console.error(error);

        rooms.forEach((room) => {
          $("#rooms").innerHTML += `
                  <div class="room">
                    <p>${room.name}</p>
                  </div>
                  `;
        });
      }

      loginForm.addEventListener("submit", handleLoginEvent);
      logoutButton.addEventListener("click", handleLogoutEvent);
      chatForm.addEventListener("submit", postChatMessage);

      async function handleLoginEvent(event) {
        event.preventDefault();
        const username = loginForm["username"].value;
        const password = loginForm["password"].value;
        const [_, error] = await useFetch("/auth/login", "POST", {
          username,
          password,
        });
        if (error) return console.error(error);

        window.location.reload();
      }

      async function handleLogoutEvent(event) {
        const [_, error] = await useFetch("/auth/logout", "POST");

        if (error) {
          console.error(error);
          return;
        }

        isAuth = false;
        authStatusBox.innerText = "Not signed in";
        loginForm.style.display = "block";
        logoutButton.style.display = "none";
        window.location.reload();
      }

      async function fetchUserProfile() {
        const [data, error] = await useFetch("/auth/profile");

        if (error) {
          console.log(`An error occured: ${error}`);
          authStatusBox.innerText = "Not signed in";
          logoutButton.style.display = "none";
          return;
        }

        isAuth = true;
        userDetails.username = data.username;
        loginForm.style.display = "none";
        authStatusBox.innerText = `Signed in as ${data.username}`;
        logoutButton.style.display = "block";
      }

      async function postChatMessage(event) {
        event.preventDefault();
        const msg = chatForm["new-msg-box"].value;

        if (!isAuth) {
          console.error("Cannot post chat message, not authenticated");
          return;
        }
        socket.emit("roomMessageEmit", {
          username: userDetails.username,
          message: msg,
        });

        chatForm["new-msg-box"].value = "";
      }

      function scrollToBottom() {
        chatArea.scrollTop = chatArea.scrollHeight;
      }

      function convertToLocalTime(utcTimestamp) {
        try {
          const utcDate = new Date(utcTimestamp);

          if (isNaN(utcDate)) {
            throw new Error("Invalid UTC timestamp");
          }

          const localTime = utcDate.toLocaleTimeString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            hour12: true,
          });

          return localTime;
        } catch (error) {
          console.error("Error converting time:", error.message);
          return null;
        }
      }

      document.addEventListener("DOMContentLoaded", async () => {
        await fetchUserProfile();
        await initialDataFetch();

        appReady = true;
      });
    </script>
  </body>
</html>
