<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Socket IO Test</title>
    <link rel="stylesheet" href="styles.css" />
    <script type="importmap">
      {
        "imports": {
          "socket.io-client": "https://cdn.socket.io/4.7.5/socket.io.esm.min.js",
          "graphql": "https://cdn.jsdelivr.net/npm/graphql@16.6.0/+esm",
          "graphql-ws": "https://cdn.jsdelivr.net/npm/graphql-ws@5.14.2/+esm"
        }
      }
    </script>
  </head>

  <body>
    <div id="connection-status-box"></div>

    <div>
      <div id="authed-view">
        <p id="auth-status-box"></p>
        <button id="logout-button">Logout</button>
      </div>

      <div id="auth-section">
        <div id="auth-tabs">
          <button class="tab-button active" data-target="signup-form">
            Signup
          </button>
          <button class="tab-button" data-target="login-form">Login</button>
        </div>

        <form class="auth-form" id="signup-form">
          <p>Signup Form</p>
          <div>
            <label for="username">Username</label>
            <input
              type="text"
              placeholder="username"
              name="username"
              id="signup-username"
            />
          </div>
          <div>
            <label for="password">Password</label>
            <input
              type="password"
              name="password"
              id="signup-password"
              placeholder="*****"
            />
          </div>
          <button type="submit">Signup</button>
        </form>

        <form class="auth-form" id="login-form">
          <p>Login Form</p>
          <div>
            <label for="username">Username</label>
            <input
              type="text"
              placeholder="username"
              name="username"
              id="login-username"
            />
          </div>
          <div>
            <label for="password">Password</label>
            <input
              type="password"
              name="password"
              id="login-password"
              placeholder="*****"
            />
          </div>
          <button type="submit">login</button>
        </form>
      </div>
    </div>

    <div id="chat-room">
      <div
        style="
          display: flex;
          align-items: center;
          justify-content: space-between;
        "
      >
        <h3 id="chat-room-name">Chat Room</h3>
        <button id="room-state-button"></button>
      </div>
      <div style="display: flex">
        <div id="users-space">
          <p>Online Users</p>
          <div id="users"></div>

          <div class="rooms-header">
            <p>Rooms</p>
            <button id="create-room-btn" class="create-room-btn">+</button>
          </div>

          <div id="rooms"></div>
        </div>
        <div id="chat-area"></div>
      </div>

      <form id="chat-form">
        <input
          placeholder="say something!"
          type="text"
          name="new-msg-box"
          id="new-msg-box"
        />
        <button type="submit">send</button>
      </form>
    </div>

    <div id="create-room-modal" class="modal">
      <div class="modal-content">
        <span class="close-modal">&times;</span>
        <h3>Create New Room</h3>
        <form id="create-room-form">
          <div>
            <label for="room-name">Room Name</label>
            <input
              type="text"
              id="room-name"
              name="room-name"
              required
              minlength="3"
              maxlength="30"
            />
          </div>
          <button type="submit">Create Room</button>
        </form>
      </div>
    </div>

    <script type="module">
      import { io } from "socket.io-client";
      import { createClient } from "graphql-ws";

      const isLocalhost = ["localhost", "127.0.0.1"].includes(
        window.location.hostname
      );
      const apiBaseURL = "https://dachatapp.onrender.com";
      const wsURL = apiBaseURL.replace(/^http/, "ws");
      const graphqlEndpoint = `${apiBaseURL}/graphql`;
      const graphqlWSEndpoint = `${wsURL}/graphql`;

      const $ = (query) => document.querySelector(query);
      const $$ = (query) => document.querySelectorAll(query);

      const chatForm = $("#chat-form");
      const authSection = $("#auth-section");
      const loginForm = $("#login-form");
      const signupForm = $("#signup-form");
      const statusIndicatorBox = $("#connection-status-box");
      const authStatusBox = $("#auth-status-box");
      const logoutButton = $("#logout-button");
      const chatArea = $("#chat-area");
      const roomStateButton = $("#room-state-button");
      const createRoomBtn = $("#create-room-btn");
      const createRoomModal = $("#create-room-modal");
      const closeModalBtn = $(".close-modal");
      const createRoomForm = $("#create-room-form");
      const tabButtons = $$(".tab-button");
      const authForms = $$(".auth-form");

      let isAuth = false;
      let appReady = false;
      let generalRoom = {};
      let activeRoom = {};
      let allUsers = [];
      let userDetails = { username: "" };
      let authToken = "";

      // GraphQL client setup
      let graphqlClient = null;

      function setupGraphQLClient(token) {
        if (token) {
          graphqlClient = createClient({
            url: graphqlWSEndpoint,
            connectionParams: {
              Authorization: `Bearer ${token}`,
            },
          });
        }
      }

      // WebSocket setup
      const socket = io(apiBaseURL, {
        reconnectionDelayMax: 10000,
        withCredentials: true,
      });

      /**
       * Fetch wrapper function
       * @param {string} endpoint - The endpoint to fetch data from.
       * @param {"GET" | "POST" | "PUT" | "DELETE"} [method="GET"] - HTTP method.
       * @param {Object} [body=null] - Request body for POST/PUT requests.
       * @param {Object} [headers={}] - Additional headers.
       * @returns {Promise<[any, Error|null]>} - Returns a tuple [data, error].
       */
      const useFetch = async (
        endpoint,
        method = "GET",
        body = null,
        headers = {},
        baseURL = apiBaseURL
      ) => {
        try {
          const options = {
            method,
            headers: { "Content-Type": "application/json", ...headers },
            body: body ? JSON.stringify(body) : null,
            credentials: "include",
          };

          const response = await fetch(`${baseURL}${endpoint}`, options);
          if (!response.ok)
            throw new Error(`${response.status} - ${response.statusText}`);
          return [await response.json(), null];
        } catch (error) {
          return [null, error];
        }
      };

      /**
       * Execute GraphQL query
       */
      const executeGraphQL = async (query, variables = {}) => {
        try {
          const headers = {};
          if (authToken) {
            headers["Authorization"] = `Bearer ${authToken}`;
          }

          const response = await fetch(graphqlEndpoint, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              ...headers,
            },
            body: JSON.stringify({
              query,
              variables,
            }),
            credentials: "include",
          });

          const result = await response.json();

          if (result.errors) {
            throw new Error(result.errors[0].message);
          }

          return [result.data, null];
        } catch (error) {
          return [null, error];
        }
      };

      function scrollToBottom() {
        chatArea.scrollTop = chatArea.scrollHeight;
      }

      function convertToLocalTime(utcTimestamp) {
        try {
          const utcDate = new Date(utcTimestamp);

          if (isNaN(utcDate)) {
            throw new Error("Invalid UTC timestamp");
          }

          const localTime = utcDate.toLocaleTimeString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            hour12: true,
          });

          return localTime;
        } catch (error) {
          console.error("Error converting time:", error.message);
          return null;
        }
      }

      function renderChatBubble(data) {
        const isCurrentUser = data.sender === userDetails.username;

        return `
          <div class="chat-bubble ${isCurrentUser ? "current-user" : ""}">
            <p class="chat-bubble-username">~${data.sender}</p>
            <div class="chat-bubble-chatdata">
              <p class="chat-bubble-message">${data.text}</p>
              <p class="chat-bubble-timestamp">${convertToLocalTime(
                data.timestamp
              )}</p>
            </div>
          </div>
        `;
      }

      function renderSystemMessage(message) {
        return `<p class="system">${message}</p>`;
      }

      function getAllRooms() {
        return Array.from($$(".room")).map((roomElem) => {
          return {
            id: roomElem.id,
            name: roomElem.textContent.trim(),
            created_by: {
              username: roomElem.dataset.createdBy,
            },
          };
        });
      }

      function updateActiveRoomName() {
        const activeRoomButton = document.getElementById(activeRoom.id);
        const activeRoomName = activeRoomButton
          ? activeRoomButton.textContent
          : "General";
        $("#chat-room-name").innerText =
          `Chat Room - ${activeRoomName}`.replace(/[\n\r]+/g, " ");
      }

      function highlightActiveRoomButton() {
        $$(".room").forEach((roomButton) => {
          roomButton.classList.remove("active-room");
        });

        const activeRoomButton = document.getElementById(activeRoom.id);
        if (activeRoomButton) {
          activeRoomButton.classList.add("active-room");
        }
      }

      function updateCreateRoomButtonVisibility() {
        createRoomBtn.style.display = isAuth ? "flex" : "none";
      }

      async function renderUsers(users) {
        $("#users").innerHTML = "";
        users.forEach((user) => {
          let baseClass = "user-status-indicator ";
          baseClass += user.isOnline ? "user-is-online" : "user-is-offline";

          $("#users").innerHTML += `
            <div class="user">
              <span class="${baseClass}"></span><p>${user.username}</p>
            </div>
          `;
        });
      }

      function addRoomToUI(room) {
        if (document.getElementById(room.id)) {
          return;
        }

        const roomElement = document.createElement("button");
        roomElement.id = room.id;
        roomElement.className = "room";
        roomElement.setAttribute(
          "data-created-by",
          room.createdBy?.username || userDetails.username
        );

        const roomNameSpan = document.createElement("span");
        roomNameSpan.textContent = room.name;

        roomElement.appendChild(roomNameSpan);

        roomElement.addEventListener("click", (event) => {
          let button = event.target;
          if (button.tagName !== "BUTTON") {
            button = button.closest("button");
          }
          switchRoom(button.id);
        });

        $("#rooms").appendChild(roomElement);
      }

      function openCreateRoomModal() {
        createRoomModal.style.display = "block";
      }

      function closeCreateRoomModal() {
        createRoomModal.style.display = "none";
        createRoomForm.reset();
      }

      function joinRoom(roomId) {
        // Socket.io approach
        socket.emit("joinRoom", {
          username: userDetails.username,
          room: roomId,
        });

        // GraphQL alternative
        const joinRoomMutation = `
          mutation JoinRoom($roomId: ID!) {
            joinRoom(roomId: $roomId)
          }
        `;

        executeGraphQL(joinRoomMutation, { roomId });
      }

      function leaveRoom(roomId) {
        // Socket.io approach
        socket.emit("leaveRoom", {
          username: userDetails.username,
          room: roomId,
        });

        // GraphQL alternative
        const leaveRoomMutation = `
          mutation LeaveRoom($roomId: ID!) {
            leaveRoom(roomId: $roomId)
          }
        `;

        executeGraphQL(leaveRoomMutation, { roomId });
      }

      async function handleRoomLoad() {
        const initialBrowserLoad = true;
        const url = new URL(window.location);
        const currentRoomId = url.searchParams.get("roomId") || generalRoom.id;
        switchRoom(currentRoomId, initialBrowserLoad);
      }

      async function switchRoom(roomId, initialBrowserLoad = false) {
        if (!roomId) {
          console.error("This room has no id");
          return;
        }

        const url = new URL(window.location);
        const currentRoomId = url.searchParams.get("roomId");

        if (currentRoomId === roomId && !initialBrowserLoad) return;

        chatArea.innerHTML = "";

        url.searchParams.set("roomId", roomId);
        window.history.pushState({}, "", url);

        socket.emit("switchToRoom", { roomId });

        // GraphQL - get room messages
        const getMessagesQuery = `
          query GetMessages($roomId: ID!) {
            getMessages(roomId: $roomId) {
              id
              sender
              text
              timestamp
            }
          }
        `;

        const [messagesData, messagesError] = await executeGraphQL(
          getMessagesQuery,
          { roomId }
        );
        if (!messagesError && messagesData?.getMessages) {
          renderRoomMessages(messagesData.getMessages);
        }

        // Get active users in room
        socket.emit("getActiveUsers", { roomId });

        // GraphQL - get active users
        const getActiveUsersQuery = `
          query GetActiveUsers($roomId: ID!) {
            getActiveUsers(roomId: $roomId)
          }
        `;

        executeGraphQL(getActiveUsersQuery, { roomId }).then(
          ([data, error]) => {
            if (!error && data?.getActiveUsers) {
              // Optionally handle active users from GraphQL
            }
          }
        );

        activeRoom.id = roomId;
        updateActiveRoomName();
        highlightActiveRoomButton();

        // Check if user is member of this room
        socket.emit("checkRoomMembership", { roomId });
      }

      function renderRoomMessages(messages) {
        chatArea.innerHTML = "";
        messages.forEach((msg) => {
          chatArea.innerHTML += renderChatBubble(msg);
        });
        scrollToBottom();
      }

      async function initialDataFetch() {
        // Use GraphQL to get initial data
        const getRoomsQuery = `
          query {
            getRooms {
              id
              name
              createdBy {
                username
              }
              meta
            }
          }
        `;

        const [roomsData, roomsError] = await executeGraphQL(getRoomsQuery);
        if (roomsError) {
          console.error("Error fetching rooms:", roomsError);
          // Fallback to REST API
          const [rooms, roomsFetchError] = await useFetch("/rooms");
          if (roomsFetchError) console.error(roomsFetchError);

          processRoomsData(rooms);
        } else {
          processRoomsData(roomsData.getRooms);
        }

        // Fetch users
        const usersFetchReq = useFetch("/users");
        const [users, usersError] = await usersFetchReq;
        if (usersError) console.error(usersError);

        allUsers = users.filter((user) => user.username !== "system");
        renderUsers(allUsers);
      }

      function processRoomsData(rooms) {
        generalRoom = rooms.find((room) => room?.meta?.isGeneral);

        $("#rooms").innerHTML = "";

        rooms.forEach((room) => {
          $("#rooms").innerHTML += `
            <button id=${room.id} class="room" 
              data-created-by="${room.createdBy?.username || ""}">
              <span>${room.name}</span>
            </button>
          `;
        });
      }

      async function fetchUserProfile() {
        // Try GraphQL first
        const getProfileQuery = `
          query {
            getProfile {
              id
              username
            }
          }
        `;

        const [profileData, profileError] = await executeGraphQL(
          getProfileQuery
        );

        if (profileError) {
          // Fallback to REST API
          const [data, error] = await useFetch("/auth/profile");

          if (error) {
            console.error(`An error occured: ${error}`);
            authStatusBox.innerText = "Not signed in";
            logoutButton.style.display = "none";
            isAuth = false;
            updateCreateRoomButtonVisibility();
            return;
          }

          processUserData(data);
        } else {
          processUserData(profileData.getProfile);
        }
      }

      function processUserData(userData) {
        isAuth = true;
        userDetails.username = userData.username;
        authSection.style.display = "none";
        authStatusBox.innerText = `Signed in as ${userData.username}`;
        logoutButton.style.display = "block";
        updateCreateRoomButtonVisibility();
      }

      async function handleLoginEvent(event) {
        event.preventDefault();
        const username = loginForm["username"].value;
        const password = loginForm["password"].value;

        // GraphQL approach
        const loginMutation = `
          mutation Login($input: LoginInput!) {
            login(input: $input) {
              accessToken
              user {
                id
                username
              }
            }
          }
        `;

        const variables = {
          input: { username, password },
        };

        const [loginData, loginError] = await executeGraphQL(
          loginMutation,
          variables
        );

        if (loginError) {
          // Fallback to REST API
          const [data, error] = await useFetch("/auth/login", "POST", {
            username,
            password,
          });

          if (error) {
            console.error(error);
            return;
          }

          if (data?.accessToken) {
            authToken = data.accessToken;
            setupGraphQLClient(authToken);
          }
        } else {
          authToken = loginData.login.accessToken;
          setupGraphQLClient(authToken);
        }

        window.location.reload();
      }

      async function handleSignupEvent(event) {
        event.preventDefault();
        const username = signupForm["username"].value;
        const password = signupForm["password"].value;

        // GraphQL approach
        const registerMutation = `
          mutation Register($input: RegisterInput!) {
            register(input: $input) {
              accessToken
              user {
                id
                username
              }
            }
          }
        `;

        const variables = {
          input: { username, password },
        };

        const [registerData, registerError] = await executeGraphQL(
          registerMutation,
          variables
        );

        if (registerError) {
          // Fallback to REST API
          const [data, error] = await useFetch("/auth/register", "POST", {
            username,
            password,
          });

          if (error) {
            console.error(error);
            return;
          }

          if (data?.accessToken) {
            authToken = data.accessToken;
            setupGraphQLClient(authToken);
          }
        } else {
          authToken = registerData.register.accessToken;
          setupGraphQLClient(authToken);
        }

        window.location.reload();
      }

      async function handleLogoutEvent(event) {
        const [_, error] = await useFetch("/auth/logout", "POST");

        if (error) {
          console.error(error);
          return;
        }

        isAuth = false;
        authToken = "";
        authStatusBox.innerText = "Not signed in";
        loginForm.style.display = "block";
        logoutButton.style.display = "none";
        window.location.reload();
      }

      async function postChatMessage(event) {
        event.preventDefault();
        const text = chatForm["new-msg-box"].value;

        if (!isAuth) {
          console.error("Cannot post chat message, not authenticated");
          return;
        }

        // Socket.io approach
        socket.emit("sendMessage", {
          text,
          roomId: activeRoom.id,
        });

        // GraphQL alternative
        const sendMessageMutation = `
          mutation SendMessage($roomId: ID!, $text: String!) {
            sendMessage(roomId: $roomId, text: $text) {
              id
              sender
              text
              timestamp
            }
          }
        `;

        executeGraphQL(sendMessageMutation, {
          roomId: activeRoom.id,
          text,
        });

        chatForm["new-msg-box"].value = "";
      }

      async function handleCreateRoomSubmit(event) {
        event.preventDefault();

        const roomName = createRoomForm["room-name"].value.trim();

        if (!roomName || roomName.length < 3) {
          alert("Room name must be at least 3 characters");
          return;
        }

        try {
          // GraphQL approach
          const createRoomMutation = `
            mutation CreateRoom($input: CreateRoomInput!) {
              createRoom(input: $input) {
                id
                name
                createdBy {
                  username
                }
              }
            }
          `;

          const [roomData, roomError] = await executeGraphQL(
            createRoomMutation,
            {
              input: { name: roomName },
            }
          );

          if (roomError) {
            // Fallback to REST API
            const [data, error] = await useFetch("/rooms", "POST", {
              name: roomName,
            });

            if (error) {
              console.error("Error creating room:", error);
              alert("Failed to create room. Please try again.");
              return;
            }

            processNewRoom(data);
          } else {
            processNewRoom(roomData.createRoom);
          }
        } catch (error) {
          console.error("Error in room creation:", error);
          alert("An unexpected error occurred. Please try again.");
        }
      }

      function processNewRoom(room) {
        closeCreateRoomModal();
        socket.emit("roomCreated", { room });
        addRoomToUI(room);
        switchRoom(room.id);
      }

      function makeContinuousTense(text) {
        const words = text.split(" ");
        if (words.length > 1) {
          let verb = words[0].toLowerCase();
          if (verb.endsWith("e") && verb !== "be") {
            verb = verb.slice(0, -1) + "ing";
          } else {
            verb += "ing";
          }
          words[0] = verb.charAt(0).toUpperCase() + verb.slice(1);
        }
        return words.join(" ");
      }

      async function joinOrLeaveRoom() {
        socket.emit("updateRoomMembership", {
          currentRoom: {
            id: activeRoom.id,
          },
        });

        roomStateButton.className = "";
        roomStateButton.textContent = makeContinuousTense(
          roomStateButton.textContent
        );
        roomStateButton.disabled = true;
      }

      async function handleAccountChickenOut(account, action) {
        const users = allUsers.filter(
          (user) => user.username !== account.username
        );
        renderUsers(users);
      }

      // Handle standardized socket events
      socket.on("event", (eventData) => {
        const { event, data } = eventData;

        switch (event) {
          case "message":
            if (typeof data === "string") {
              chatArea.innerHTML += renderSystemMessage(data);
            } else {
              chatArea.innerHTML += renderChatBubble(data);
            }
            scrollToBottom();
            break;

          case "previousMessages":
            renderRoomMessages(data);
            break;

          case "onlineUsers":
            setTimeout(() => {
              const onlineUsersUsernames = data.map((user) => user.username);

              const existingUsernames = new Set(
                allUsers.map((user) => user.username)
              );

              const updatedUsers = allUsers.map((user) => ({
                ...user,
                isOnline: onlineUsersUsernames.includes(user.username),
              }));

              const newUsers = data
                .filter(
                  (onlineUser) => !existingUsernames.has(onlineUser.username)
                )
                .map((onlineUser) => ({
                  username: onlineUser.username,
                  isOnline: true,
                  id: onlineUser.id || null,
                }));

              const combinedUsers = [...updatedUsers, ...newUsers];

              allUsers = combinedUsers;

              renderUsers(combinedUsers);
            }, 1000);
            break;

          case "roomJoinSuccess":
            // Handle room join success
            break;

          case "roomLeaveSuccess":
            // Handle room leave success
            break;

          case "roomMembershipStatus":
            if (data.isMember) {
              roomStateButton.innerText = "Leave room";
              roomStateButton.className = "leave-room-btn";
            } else {
              roomStateButton.innerText = "Join room";
              roomStateButton.className = "join-room-btn";
            }

            roomStateButton.disabled = false;
            break;

          case "activeUsers":
            // Update list of active users in room
            break;

          case "newRoom":
            addRoomToUI(data);
            break;

          case "userDeleted":
            handleAccountChickenOut(data.userData);
            break;
        }
      });

      socket.on("connect", () => {
        statusIndicatorBox.innerText = "connected!";
      });

      socket.on("connect_error", (err) => {
        statusIndicatorBox.innerText = "connect error";
        console.error("Connection failed:", err.message);
      });

      socket.on("disconnect", () => {
        statusIndicatorBox.innerText = "disconnected";
      });

      // Setup GraphQL subscriptions if needed
      function setupGraphQLSubscriptions(roomId) {
        if (!graphqlClient) return;

        // Message subscription
        const messageAddedSubscription = `
          subscription MessageAdded($roomId: ID!) {
            messageAdded(roomId: $roomId) {
              id
              sender
              text
              timestamp
            }
          }
        `;

        const unsubMessage = graphqlClient.subscribe(
          {
            query: messageAddedSubscription,
            variables: { roomId },
          },
          {
            next: (data) => {
              const message = data.data.messageAdded;
              chatArea.innerHTML += renderChatBubble(message);
              scrollToBottom();
            },
            error: (error) => console.error("Subscription error:", error),
            complete: () => console.log("Subscription complete"),
          }
        );

        // User joined subscription
        const userJoinedSubscription = `
          subscription UserJoined($roomId: ID!) {
            userJoined(roomId: $roomId)
          }
        `;

        const unsubUserJoined = graphqlClient.subscribe(
          {
            query: userJoinedSubscription,
            variables: { roomId },
          },
          {
            next: (data) => {
              const username = data.data.userJoined;
              chatArea.innerHTML += renderSystemMessage(
                `${username} joined the room`
              );
              scrollToBottom();
            },
            error: (error) => console.error("Subscription error:", error),
          }
        );

        // User left subscription
        const userLeftSubscription = `
          subscription UserLeft($roomId: ID!) {
            userLeft(roomId: $roomId)
          }
        `;

        const unsubUserLeft = graphqlClient.subscribe(
          {
            query: userLeftSubscription,
            variables: { roomId },
          },
          {
            next: (data) => {
              const username = data.data.userLeft;
              chatArea.innerHTML += renderSystemMessage(
                `${username} left the room`
              );
              scrollToBottom();
            },
            error: (error) => console.error("Subscription error:", error),
          }
        );

        // Return a cleanup function
        return () => {
          unsubMessage();
          unsubUserJoined();
          unsubUserLeft();
        };
      }

      setInterval(() => {
        socket.emit("heartbeat");
      }, 30 * 1000);

      loginForm.addEventListener("submit", handleLoginEvent);
      signupForm.addEventListener("submit", handleSignupEvent);
      logoutButton.addEventListener("click", handleLogoutEvent);
      chatForm.addEventListener("submit", postChatMessage);
      createRoomBtn.addEventListener("click", openCreateRoomModal);
      closeModalBtn.addEventListener("click", closeCreateRoomModal);
      createRoomForm.addEventListener("submit", handleCreateRoomSubmit);
      roomStateButton.addEventListener("click", joinOrLeaveRoom);

      window.addEventListener("click", (event) => {
        if (event.target === createRoomModal) {
          closeCreateRoomModal();
        }
      });

      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          tabButtons.forEach((btn) => btn.classList.remove("active"));
          authForms.forEach((form) => form.classList.remove("active"));

          button.classList.add("active");
          document
            .getElementById(button.dataset.target)
            .classList.add("active");
        });
      });

      document.querySelector(".tab-button.active").click();

      document.addEventListener("DOMContentLoaded", async () => {
        await fetchUserProfile();
        await initialDataFetch();
        socket.emit("getOnlineUsersUpdate");

        handleRoomLoad();
        updateCreateRoomButtonVisibility();

        $$(".room").forEach((room) => {
          room.addEventListener("click", (event) => {
            let button = event.target;
            if (button.tagName !== "BUTTON") {
              button = button.closest("button");
            }
            switchRoom(button.id);
          });
        });

        appReady = true;
      });
    </script>
  </body>
</html>
